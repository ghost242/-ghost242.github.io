---
layout: post
title: 관계 테이블을 엮어서 쿼리하는 방법
subtitle: Correlated 테이블에 대해서
parent: Database
category: ["Database", "Transaction"]
tags: ["Database", "MySQL", "PostgreSQL", "Python", "SQLAlchemy"]
---

## 개요

쿼리를 작성하던 도중에 쿼리 실행속도가 초단위로 걸리는 경우를 보게됐다. 1:N:N 관계에 있는 세개의 테이블을 join 하는 쿼리였는데, 그 중에 N:N 인 두 테이블은 Subquery로 묶어야 했고, 총 150만 레코드에서 쿼리한 결과를 다시 join 해야 하는 작업이었다. 작업을 하던 도중에 Subquery에 limit을 이용해서 레코드 수를 제한하면 더 빠른 속도로 쿼리를 수행할 수 있을 것으로 예상하게됐는데 SQL에 대해 잘 모르는 상태에서 이런 쿼리를 작성할 수 있는지 확신이 없었다. 

그런 도중에 알게 된 새로운 것이 있어서 기록을 남겨본다. 

## 예시

알기 쉽게 ㄴ

개요
이 문법은 기존에 DML 쿼리를 좀 더 최적화된 기법으로 구성하기위해 생긴 키워드로, 관계 데이터간의 연관성을 의미한다고 볼 수 있다. 따라서 단독으로 사용은 불가능하고 JOIN 으로 관계된 서브쿼리를 통해 사용허는 것이 일반적이다. 
본문
문제 발생
계기는 사소한 문제였는데, 간단히 예를 들자면 1:N 관계인 두 테이블에서 JOIN 을 통해 쿼리를 할 때 쿼리조건으로 인해 5만개 이상의 레코드가 조회되었다. 
이때 한쪽에는 1만개가량의 레코드가 있었고 다른 한쪽에는 100만개정도의 레코드가 있어서 쿼리시간도 3초정도 걸리게 되었다. 
게다가 실제 필요한 데이터는 테이블 A의 각 레코드별로 테이블 B의 레코드가 최대 4개까지만 쿼리되면 충분했기 때문에 시간, 공간적인 최적화가 필요한 상태였다.
해결
초기에는 JOIN을 제거하고 테이블 A의 결과만큼 반복쿼리을 수행해서 테이블 B의 레코드를 LIMIT으로 제어할 생각이었으나 DBMS와의 레이턴시를 생각하면 시간이 전혀 줄어들지 않는 문제가 있었고 테이블 A에 대한 쿼리조건을 테이블 B에 적용해서 코드수준에서 반복하려고 해도 마찬가지로 불필요한 데이터가 너무 많이 쿼리되는 문제가 있어 찾게된 방법이 LATERAL구문이었다.
이 구문을 통해 두 테이블의 서브쿼리를 JOIN으로 묶게되면서 최적화가 가능하게 되었다.
이론적 배경
이 구문은 Correlated data 간의 관계를 구성하는 것으로 볼 수 있으며 조건을 만족하는 각 레코드마다 서브쿼리조건을 적용하는 것을 의미한다. 따라서 특정한 서브쿼리에 베이스가 되는 테이블의 pk를 fk와 연고나
성능 비교
타 시스템과 비교
결론
